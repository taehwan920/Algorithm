n = int(input())
time = [0]
pay = [0]
# 헷갈리지 않게 걸리는 시간과 상담료는 따로 저장
dp = [0 for i in range(n+1)]

for i in range(n):
    t, p = map(int, input().split())
    time.append(t)
    pay.append(p)

for i in range(1, n+1):
    # i + time[i] - 1로 설정한 이유는 1일날 3일 걸리는 상담을 진행하면 시작 당일인 1일도 포함되어 3일에 끝난다. 그래서 끝나는 날을 지정하기 위해 다음과 같이 구현했다.
    if i + time[i] - 1 > n:
        # 상담 종료일이 주어진 날짜보다 뒤에 있을 경우 스킵
        continue
    dp[i+time[i]-1] = max(max(dp[:i]) + pay[i], dp[i+time[i]-1])
    # 메모이제이션은 각 날짜별 상담 수익을 저장하는 배열 dp로 진행한다.
    # 상담 시작일보다 이전에 얻은 수익 중 가장 큰 수익과 이미 저장되어있는 상담 수익 중 더 큰 것을 저장한다.
    # 상담 시작일보다 이전에 저장되어있는 수익은 진행하고자 하는 상담과 아무 상관이 없기 때문에 상담 시작일 이전의 수익들 중 가장 큰 것을 가져오도록 하였음.
    # 원래 dp[:i]이 아니라 dp[i-1]로 했어서 계속 틀렸었다.

print(max(dp))
# 가장 큰 상담 수익을 저장한다.

# 다른 해답을 찾아보니 재귀형식으로 풀거나 dp로 풀어도 뒤에서부터 dp를 저장해나가는 형식의 풀이가 있었다.
