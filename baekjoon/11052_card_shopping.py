n = int(input())
card = [0] + list(map(int, input().split()))
dp = [0 for i in range(n+1)]
dp[1] = card[1]
dp[2] = max(card[2], card[1]*2)

for i in range(3, n+1):
    dp[i] = card[i]
    for j in range(1, i // 2 + 1):
        dp[i] = max(dp[i], dp[j] + dp[i-j])

print(max(dp))

# 이 문제의 관건은 메모이제이션의 개념 이해도.
# 예를 들어 dp[3]을 계산한다고 치면 (1, 1, 1), (2, 1), (3)으로 총 3가지 경우의 수가 있는데 여기서 (1, 1, 1)과 (2, 1)은 구분할 필요가 없다.
# 왜냐면 (1, 1, 1)의 일부인 (1, 1)과 (2, 1)의 일부인 (2)는 이미 dp[2]에서 어느쪽이 큰지 증명 되었기 때문에 비교할 필요가 없다.
# 이런 식으로 굳이 비교할 필요가 없는 요소들이 있기때문에 이들을 배제하고 계산하는 식을 만들면 된다.
# 그리고 j 반복문의 range안에 있는 i // 2 + 1은 1부터 i를 포함한 그 사이의 수들을 짝지어 훑는 것이기 때문에 탐색 범위를 절반으로 설정하기 위해 i // 2 + 1로 설정.
