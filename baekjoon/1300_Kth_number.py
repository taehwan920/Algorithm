n, k = int(input()), int(input())

start = 1
end = k
result = 0

while start <= end:
    mid = (start + end) // 2
    temp = 0
    for i in range(1, n+1):
        temp += min(mid // i, n)

    if temp >= k:
        result = mid
        end = mid - 1
    else:
        start = mid + 1

print(result)

# 동적 프로그래밍과 이분탐색이 섞인거나 다름없는 문제.
# 어느 수가 k번째 수인지 판단하려면 그것보다 작은 수가 k-1개 있어야 가능하다. 자연수 중 5가 몇번째 수인지 판단하려면 그보다 작은 수가 4개 있어야 하는것 처럼.
# 그래서 최소값을 첫번째 수라는 의미에서 1로 잡고, 최대값을 주어진 k로 설정한 뒤 이 중간값보다 작은 수가 몇개있는지 찾아야함.
# 예를 들어 10*10에서 20보다 작거나 같은 수를 찾아보자면
# 1*1 ~ 1*10, 2*1 ~ 2*10, 3*1 ~ 3*6 ... 이런식으로 존재할 것.
# 이건 무슨 뜻이냐 하면 구하고자하는 20을 행의 번호로 나눈 몫과 같음.
# 하지만 1번 행의 경우 원래는 1~20까지 수가있겠지만 배열 자체가 10*10 이니 1~10까지 밖에 없고
# 이를 식으로 표현하면 min(mid // i, n)으로 표현 가능. 즉 나눈 몫이 배열 크기보다 클 순 없으므로.
# temp 변수는 mid보다 작은 숫자의 개수를 전부 찾아줌으로써 mid가 몇번째에 위치한 숫자인지 알 수 있게 해준다.
# 그래서 여느때와는 달리 temp가 구하고자하는 수보다 크거나 같을때 result변수를 저장해주도록 함.
