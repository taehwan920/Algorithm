n = int(input())
if n == 1:
    print(1)
    exit(0)

cnt = 0
while 2 ** cnt < n:
    cnt += 1

idx = n - 2 ** cnt - 1
nums = [2 * i for i in range(1, 2**(cnt-1)+1)]
print(nums[idx])

# 이게 왜 시뮬레이션 문제인지 알 수 없던 문제. C++로 풀면 그냥 단순 구현으로도 풀리는문젠가?
# 파이썬으로 풀기위해선 dp식 접근법이 필요했음.
# 1부터 숫자를 넣어보면 1, 2, 2, 4, 2, 4, 6, 8, 2, 4 ... 이런 식으로 2부터는 특정한 규칙이 있다는 걸 알 수 있다.
# 주어진 숫자보다 작은 2의 제곱수중 가장 큰 수의 지수를 구한다. 5의 경우 5보다 작은 2의 제곱수 중 가장 큰 수는 4이므로 그 지수는 2임.
# 이 때 5가 속해 있는 수의 집합은 5보다 작은 2의 제곱수 중 가장 큰 수인 4보다 작거나 같은 모든 자연수가 2와 곱해진 집합임. 예시의 경우 [2, 4, 6, 8]이라는 집합을 구할 수 있음. => nums 배열
# 이 집합에서의 5의 인덱스를 구하기 위해 5에서 4를빼고, 여기서 또 1을 빼준다(배열은 0부터 시작하므로)
# 구한 집합 내에서 인덱스를 이용해 숫자를 찾으면 답이 나온다.
